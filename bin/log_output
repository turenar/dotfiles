#!/bin/bash
# vim: ts=4:sw=4
# This file is under public domain. You can do anything without any permissions.

function print_help()
{
	cat <<EOF
usage: $0 [OPTION]... [--] <command> [<arg>...]
options:
  -P, --print-always      print even if command is succeeded
  -M, --max-line N        print the first N lines instead of all;
                           with the leading '-', print all but the last N lines.
  -t, --timestamp         print timestamp each line (TOOOOOOO SLOW)
  -E, --print-exitcode    print exit code at the end
  -h, --help              display this help and exit


This script is usually faster than https://github.com/kazuho/kaztools/blob/master/cronlog,
  but if --timestamp is passed, this is too much slowly than that script.
You can specify '--max-line N' option with '--timestamp'. If you specify
  small number as N, it's sometimes faster than \`cronlog <command> | head -n N'

This script is under public domain. You can do anything without any permissions.
EOF
}

function main() {
	local __opt __arg __saved_arg __arg_consumed __should_shift_arg

	while [ -n "$1" ]; do
		__arg_consumed=''
		__should_shift_arg='' # if true and __arg_consumed==true, shift argument
		if [ -n "${__saved_arg}" ]; then # -abcdef...
			__opt="-${__saved_arg:0:1}"
			__arg="${__saved_arg:1}"
			__saved_arg="$__arg"
		elif [[ "$1" == --*=* ]]; then # --hoge=fuga
			__opt=${1%%=*}
			__arg="${1#*=}"
		elif [[ "$1" == --* ]]; then # --hoge [fuga]
			__opt="$1"
			__arg="$2"
			__should_shift_arg=true
		elif [[ "$1" == -??* ]]; then # -abcdef...: first pass
			__saved_arg="${1:1}"
			continue
		elif [[ "$1" == -? ]]; then # -a
			__opt="$1"
			__arg="$2"
			__should_shift_arg=true
		else
			break
		fi
		echo -- ${__opt} ${__arg}
		case "${__opt}" in
			-M|--max-line)
				test -z "${__arg}" && _die "'${__opt}' requires argument"
				_max_line=$__arg
				__arg_consumed=true;;
			-P|--print-always)
				_print_always=true;;
			-t|--timestamp)
				_print_timestamp=true;;
			-E|--print-exitcode)
				_print_exitcode=true;;
			-h|--help)
				print_help
				exit 0;;
			--)
				shift
				break;;
			-*)
				_die "unknown option: $1";;
			*)
				break # dead code
		esac

		if [ -n "${__arg_consumed}" ]; then
			# if arg is consumed and saved_arg is not null, saved_arg is arg
			__saved_arg=''
			if [ -n "$__should_shift_arg" ]; then
				shift
			fi
		fi

		if [ -z "$__saved_arg" ]; then
			shift
		fi
	done

	if [ -z "$1" ]; then
		_die 'missing operand'
	fi

	outfile=$(mktemp)
	exec 8>${outfile}
	exec 7<${outfile}
	rm ${outfile}
	# trap output if filter (aka. _print_timestamp) enabled
	if [ -n "${_print_timestamp}" ]; then
		infile=$(mktemp -u)
		mkfifo -m600 ${infile}
		"$@" >${infile} 2>&1 &
		pid=$!
		exec 9<${infile}
		rm ${infile}

		SECONDS=$(date +%s)

		if [ -v _max_line ]; then
			i=0
			while read -u 9 line; do
				echo "[${SECONDS}] ${line}" >&8
				let i++
				if [ $i -ge ${_max_line} ]; then
					break
				fi
			done
			cat <&9 >/dev/null
		else
			while read -u 9 line; do
				echo "[${SECONDS}] ${line}" >&8
			done
		fi
	else
		"$@" >&8 2>&8 &
		pid=$!
	fi

	wait ${pid}
	errorcode=$?
	if [ -n "${_print_always}" -o ${errorcode} -ne 0 ]; then
		if [ -v _max_line ]; then
			head -n ${_max_line} <&7
		else
			cat <&7
		fi
		if [ -n "${_print_exitcode}" ]; then
			msg="<$(basename "$1")> exit $errorcode"
			if [ -n "${_print_timestamp}" ]; then
				echo "[${SECONDS}] $msg"
			else
				echo "$msg"
			fi
		fi
	fi
	exit ${errorcode}
}

function _die() {
	echo "$(basename "$0"): $1" >&2
	exit 1
}


main "$@"
