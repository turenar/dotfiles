#!/bin/bash
# vim: ts=4:sw=4
# This file is under public domain. You can do anything without any permissions.

function usage() {
	echo "usage: $0 [OPTION]... [--] <command> [<arg>...]"
}

function print_help() {
	usage
	cat <<EOF
options:
  -P, --print-always      print even if command is succeeded
  -M, --max-lines N       print the first N lines instead of all;
                           with the leading '-', print all but the last N lines.
  -t, --timestamp         print timestamp each line
  -E, --print-exitcode    print exit code at the end
  -o, --output FILE       set output file instead of stdout. FILE will be
                           truncated.
  -a, --append            append to file instead of truncate. use with
                           '--output'
  -L, --log-file FILE     output all logs into FILE. FILE will not be truncated.
                           '--timestamp' don't affect to FILE.
                           use '--output FILE --append'
      --check-requirement check required command (aka. awk) is installed and
                           exit; no output if succeeded. This option don't check
                           whether commands work as we expect.
  -h, --help              display this help and exit


This script is under public domain. You can do anything without any permissions.
EOF
	check_env
}

function main() {
	local __opt __arg __saved_arg __arg_consumed __should_shift_arg

	while [ -n "$1" ]; do
		__arg_consumed=''
		__should_shift_arg='' # if true and __arg_consumed==true, shift argument
		if [ -n "${__saved_arg}" ]; then # -abcdef...
			__opt="-${__saved_arg:0:1}"
			__arg="${__saved_arg:1}"
			__saved_arg="$__arg"
		elif [[ "$1" == --*=* ]]; then # --hoge=fuga
			__opt=${1%%=*}
			__arg="${1#*=}"
		elif [[ "$1" == --* ]]; then # --hoge [fuga]
			__opt="$1"
			__arg="$2"
			__should_shift_arg=true
		elif [[ "$1" == -??* ]]; then # -abcdef...: first pass
			__saved_arg="${1:1}"
			continue
		elif [[ "$1" == -? ]]; then # -a
			__opt="$1"
			__arg="$2"
			__should_shift_arg=true
		else
			break
		fi
		# echo -- ${__opt} ${__arg} >&2
		case "${__opt}" in
			-M|--lines|--max-line|--max-lines)
				test -z "${__arg}" && _die "'${__opt}' requires argument"
				_max_line=$__arg
				__arg_consumed=true;;
			-P|--print-always)
				_print_always=true;;
			-t|--tstamp|--timestamp)
				_print_timestamp=true;;
			-E|--print-exitcode)
				_print_exitcode=true;;
			-o|--output)
				test -z "${__arg}" && _die "'${__opt}' requires argument"
				_output="${__arg}"
				__arg_consumed=true;;
			-a|--append)
				_out_append=true;;
			-L|--log-file)
				test -z "${__arg}" && _die "'${__opt}' requires argument"
				_log_output="${__arg}"
				__arg_consumed=true;;
			--check-requirement)
				check_env
				exit 0;;
			-h|--help)
				print_help
				exit 0;;
			--)
				shift
				break;;
			-*)
				_die "unknown option: $1";;
			*)
				break # dead code
		esac

		if [ -n "${__arg_consumed}" ]; then
			# if arg is consumed and saved_arg is not null, saved_arg is arg
			__saved_arg=''
			if [ -n "$__should_shift_arg" ]; then
				shift
			fi
		fi

		if [ -z "$__saved_arg" ]; then
			shift
		fi
	done

	if [ -z "$1" ]; then
		usage >&2
		echo "Try '$(basename "$0") --help' for more information." >&2
		exit 1
	fi

	# handle --output
	if [ -n "${_output}" ]; then
		if [ -z "${_out_append}" ]; then
			exec 1>"${_output}"
		else
			exec 1>>"${_output}"
		fi
	fi
	# ----- arg parser end -----

	outfile=$(mktemp)
	exec 8>${outfile}
	exec 7<${outfile}
	rm ${outfile}
	# trap output if filter (aka. _print_timestamp) enabled
	if [ -n "${_print_timestamp}" ]; then
		if [ -n "${_log_output}" ]; then
			infile="${_log_output}"
			touch "${infile}" # ensure file exists
			# ensure seek position
			exec 9<${infile}
			"$@" >>${infile} 2>&1 &
		else
			infile=$(mktemp -u)
			mkfifo -m600 ${infile}
			# ensure write opened
			"$@" >>${infile} 2>&1 &
			exec 9<${infile}
		fi
		pid=$!
		[ -z "${_log_output}" ] && rm ${infile}

		if [ -v _max_line ]; then
			head -n $(( ${_max_line} + 1 )) <&9 | \
				awk '{ m = strftime("%s") ; printf "[%s] %s\n", m, $0 }' >&8
			exec 9<&-
		else
			awk '{ m = strftime("%s") ; printf "[%s] %s\n", m, $0 }' <&9 >&8
		fi
	else
		if [ -n "${_log_output}" ]; then
			if [ -v _max_line ]; then
				"$@" 2>&1 | tee -a "${_log_output}" | head -n $(( ${_max_line} + 1 )) >&8 &
			else
				"$@" 2>&1 | tee -a "${_log_output}" >&8 &
			fi
		else
			if [ -v _max_line ]; then
				"$@" 2>&1 | head -n $(( ${_max_line} + 1 )) >&8 &
			else
				"$@" >&8 2>&1 &
			fi
		fi
		pid=$!
	fi

	wait ${pid}
	errorcode=$?
	if [ -n "${_print_always}" -o ${errorcode} -ne 0 ]; then
		if [ -v _max_line ]; then
			head -n ${_max_line} <&7
			# Check all output is read
			if read -u7 ignore; then
				msg=" <truncated output>"
			fi
		else
			cat <&7
		fi
		if [ -n "${_print_exitcode}" ]; then
			msg="${msg} <'$(basename "$1")' exit ${errorcode}>"
		fi
		if [ -n "${msg}" ]; then
			if [ -n "${_print_timestamp}" ]; then
				echo "[$(date +%s)] [$(basename "$0"):${msg}]"
			else
				echo "[$(basename "$0"):${msg}]"
			fi
		fi
	fi
	exit ${errorcode}
}

function check_env(){
	check_cmd awk
	check_cmd date
	[ "$(date +%s)" = "$(echo | awk '{ printf strftime("%s") }')" ] || echo "WARN: awk is not supported strftime?" >&2
	check_cmd head
	check_cmd mkfifo
	check_cmd mktemp
	check_cmd tee
	check_cmd touch
}

function check_cmd() {
	which $1 >/dev/null 2>&1 || echo "WARN: command '$1' is not found." >&2
}

function _die() {
	echo "$(basename "$0"): $1" >&2
	exit 1
}


main "$@"
