#!/bin/bash
# vim: ts=4:sw=4
# This file is under public domain. You can do anything without any permissions.

function print_help()
{
	cat <<EOF
usage: $0 [OPTION]... [--] <command> [<arg>...]
options:
  -P, --print-always      print even if command is succeeded
  -M, --max-lines N       print the first N lines instead of all;
                           with the leading '-', print all but the last N lines.
  -t, --timestamp         print timestamp each line
  -E, --print-exitcode    print exit code at the end
  -h, --help              display this help and exit


This script is under public domain. You can do anything without any permissions.
EOF
	check_env
}

function main() {
	local __opt __arg __saved_arg __arg_consumed __should_shift_arg

	while [ -n "$1" ]; do
		__arg_consumed=''
		__should_shift_arg='' # if true and __arg_consumed==true, shift argument
		if [ -n "${__saved_arg}" ]; then # -abcdef...
			__opt="-${__saved_arg:0:1}"
			__arg="${__saved_arg:1}"
			__saved_arg="$__arg"
		elif [[ "$1" == --*=* ]]; then # --hoge=fuga
			__opt=${1%%=*}
			__arg="${1#*=}"
		elif [[ "$1" == --* ]]; then # --hoge [fuga]
			__opt="$1"
			__arg="$2"
			__should_shift_arg=true
		elif [[ "$1" == -??* ]]; then # -abcdef...: first pass
			__saved_arg="${1:1}"
			continue
		elif [[ "$1" == -? ]]; then # -a
			__opt="$1"
			__arg="$2"
			__should_shift_arg=true
		else
			break
		fi
		# echo -- ${__opt} ${__arg}
		case "${__opt}" in
			-M|--lines|--max-line|--max-lines)
				test -z "${__arg}" && _die "'${__opt}' requires argument"
				_max_line=$__arg
				__arg_consumed=true;;
			-P|--print-always)
				_print_always=true;;
			-t|--tstamp|--timestamp)
				_print_timestamp=true;;
			-E|--print-exitcode)
				_print_exitcode=true;;
			-h|--help)
				print_help
				exit 0;;
			--)
				shift
				break;;
			-*)
				_die "unknown option: $1";;
			*)
				break # dead code
		esac

		if [ -n "${__arg_consumed}" ]; then
			# if arg is consumed and saved_arg is not null, saved_arg is arg
			__saved_arg=''
			if [ -n "$__should_shift_arg" ]; then
				shift
			fi
		fi

		if [ -z "$__saved_arg" ]; then
			shift
		fi
	done

	if [ -z "$1" ]; then
		_die 'missing operand'
	fi

	outfile=$(mktemp)
	exec 8>${outfile}
	exec 7<${outfile}
	rm ${outfile}
	# trap output if filter (aka. _print_timestamp) enabled
	if [ -n "${_print_timestamp}" ]; then
		infile=$(mktemp -u)
		mkfifo -m600 ${infile}
		"$@" >${infile} 2>&1 &
		pid=$!
		exec 9<${infile}
		rm ${infile}

		SECONDS=$(date +%s)

		if [ -v _max_line ]; then
			head -n $(( ${_max_line} + 1 )) <&9 | \
				awk '{ m = strftime("%s") ; printf "[%s] %s\n", m, $0 }' >&8
			# doesn't fifo handle broken pipe?
			cat <&9 >/dev/null
		else
			awk '{ m = strftime("%s") ; printf "[%s] %s\n", m, $0 }' <&9 >&8
		fi
	else
		"$@" >&8 2>&8 &
		pid=$!
	fi

	wait ${pid}
	errorcode=$?
	if [ -n "${_print_always}" -o ${errorcode} -ne 0 ]; then
		if [ -v _max_line ]; then
			head -n ${_max_line} <&7
			if read -u7 ignore; then
				msg=" <truncated output>"
			fi
		else
			cat <&7
		fi
		if [ -n "${_print_exitcode}" ]; then
			msg="${msg} <'$(basename "$1")' exit ${errorcode}>"
		fi
		if [ -n "${msg}" ]; then
			if [ -n "${_print_timestamp}" ]; then
				echo "[${SECONDS}] [$(basename "$0"):${msg}]"
			else
				echo "[$(basename "$0"):${msg}]"
			fi
		fi
	fi
	exit ${errorcode}
}

function check_env(){
	check_cmd awk
}

function check_cmd() {
	which $1 >/dev/null 2>&1 || echo "WARN: command '$1' is not found."
}

function _die() {
	echo "$(basename "$0"): $1" >&2
	exit 1
}


main "$@"
